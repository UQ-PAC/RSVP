/*
 * This source file was generated by the Gradle 'init' task
 */
package policygen;

import java.io.FileOutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;

import policygen.entity.Entity;
import policygen.entity.FileResource;
import policygen.entity.Folder;
import policygen.entity.Group;
import policygen.entity.User;
import uq.pac.rsvp.policy.ast.expr.BinaryExpression;
import uq.pac.rsvp.policy.ast.expr.BooleanExpression;
import uq.pac.rsvp.policy.ast.expr.EntityExpression;
import uq.pac.rsvp.policy.ast.expr.Expression;
import uq.pac.rsvp.policy.ast.expr.LongExpression;
import uq.pac.rsvp.policy.ast.expr.PropertyAccessExpression;
import uq.pac.rsvp.policy.ast.expr.RecordExpression;
import uq.pac.rsvp.policy.ast.expr.StringExpression;
import uq.pac.rsvp.policy.ast.expr.UnaryExpression;
import uq.pac.rsvp.policy.ast.expr.VariableExpression;

public class App {

    private static Random random = new Random();

    public static void main(String[] args) throws Exception {

        try (FileOutputStream policyOutFS = new FileOutputStream("policy-out.cedar")) {
            PrintStream policyOut = new PrintStream(policyOutFS);

            Group adminGroup = new Group("Admins", null);
            Group staffGroup = new Group("Staff", null);
            Group seniorStaffGroup = new Group("SeniorStaff", staffGroup);

            ArrayList<User> userList;
            ArrayList<Group> groupList;
            ArrayList<Folder> folderList;
            ArrayList<FileResource> fileList;

            groupList = new ArrayList<>();
            groupList.add(adminGroup);
            groupList.add(staffGroup);
            groupList.add(seniorStaffGroup);

            userList = new ArrayList<>();
            userList.add(new User("Joe", 25, 5, adminGroup));
            userList.add(new User("Sally", 33, 7, staffGroup));
            userList.add(new User("Matumbah", 56, 3, seniorStaffGroup));
            userList.add(new User("Philip", 21, 3, null /* no group */));

            folderList = new ArrayList<>();
            for (int i = 0; i < 10; i++) {
                folderList.add(new Folder(null));
            }

            fileList = new ArrayList<>();
            for (int i = 0; i < 100; i++) {
                Folder parent = folderList.get(random.nextInt(folderList.size()));
                fileList.add(new FileResource(parent));
            }

            EntityPool pool = new EntityPool();
            groupList.forEach(g -> pool.addEntity(g));
            userList.forEach(u -> pool.addEntity(u));
            folderList.forEach(f -> pool.addEntity(f));
            fileList.forEach(f -> pool.addEntity(f));

            SchemaWrapper schema = new SchemaWrapperDefault();

            for (int i = 0; i < 100; i++) {
                generatePolicy(policyOut, pool, schema);
            }
        }
    }

    private static boolean randomChance(int percent) {
        return random.nextInt(100) < percent;
    }

    private static void generatePolicy(PrintStream output, EntityPool entities, SchemaWrapper schema) {
        // "permit" or "forbid"?
        // 60% permit
        boolean isPermit = randomChance(60);
        String policyStr = isPermit ? "permit (\n" : "forbid (\n";

        // Need principal, action, resource, conditions
        String principal = randomPrincipal(entities, schema);
        policyStr += "    " + principal + ",\n";

        String action = randomAction();
        policyStr += "    " + action + ",\n";

        String resource = randomResource(entities, schema);
        policyStr += "    " + resource + "\n";

        policyStr += ")";

        int conditionChance = 70;
        while (randomChance(conditionChance)) {
            policyStr += "\n" + generateCondition(entities, schema);
            conditionChance = 25; // reduced chance of additional conditions
        }

        policyStr += ";\n";
        output.println(policyStr);
    }

    private static String randomPrincipal(EntityPool entities, SchemaWrapper schema) {
        return randomMultiple("principal", schema.getPrincipalType(), entities, schema);
    }

    private static String randomResource(EntityPool entities, SchemaWrapper schema) {
        return randomMultiple("resource", schema.getResourceType(), entities, schema);
    }

    private static String randomMultiple(String varName, CedarEntityRef entityType,
            EntityPool entities, SchemaWrapper schema) {
        // Can be a specific principal ('principal == User::"boo_radley"'), an "is" clause
        // (type check),  or a membership check ('principal in Group::"fun_llamas"') optionally
        // combined with "is" clause

        // TODO: generate "is" clauses.

        int principalForm = random.nextInt(100);
        if (principalForm < 25) {
            return varName;
        }
        if (principalForm < 50) {
            Entity entity = entities.getRandomEntityOfType(entityType, random);
            return varName + " == " + entity.toEntityString();
        }
        else {
            Collection<CedarEntityRef> ancestorTypes = schema.getAncestorTypes(entityType);
            int chosenIndex = random.nextInt(ancestorTypes.size());
            Iterator<CedarEntityRef> iter = ancestorTypes.iterator();
            for (int i = 0; i < chosenIndex; i++)
                iter.next();
            CedarEntityRef chosenType = iter.next();
            Entity chosenEntity = entities.getRandomEntityOfType(chosenType, random);
            return varName + " in " + chosenEntity.toEntityString();
        }
    }

    private static String randomAction() {
        // FIXME get possible actions from schema
        int actionIndex = random.nextInt(4);
        switch (actionIndex) {
        case 0:
            return "action == Action::\"read\"";
        case 1:
            return "action == Action::\"update\"";
        case 2:
            return "action == Action::\"remove\"";
        default: /* 3 */
            return "action";
        }
    }

    private static class ExpressionWithType {
        Expression expression;
        CedarType exprType;
    }

    /**
     * Generate an expression with a value of arbitrary type.
     */
    private static ExpressionWithType generateValueExpr(EntityPool entities, SchemaWrapper schema,
            boolean allowLiterals) {

        Expression valueExpr;
        CedarType valueType;

        int valueTypeIndex = random.nextInt(100);
        // 35% principal, 35% resources, 30% context
        if (valueTypeIndex < 35) {
            // principal.
            valueExpr = VariableExpression.createPrincipalRef(null);
            valueType = schema.getPrincipalType();
        }
        else if (valueTypeIndex < 70) {
            // resource
            valueExpr = VariableExpression.createResourceRef(null);
            valueType = schema.getResourceType();
        }
        else {
            // context
            valueExpr = VariableExpression.createContextRef(null);
            valueType = schema.getRequestType();
        }

        // Potentially drill down, i.e. select a field
        while (randomChance(80)) {
            if (valueType.getTypeId() != CedarType.TypeId.ENTITY
                    && valueType.getTypeId() != CedarType.TypeId.RECORD)
                break;

            Map<String, CedarType> fields = valueType.getFields();

            if (!fields.isEmpty()) {
                // Choose a field at random:
                int fieldIndex = random.nextInt(fields.size());
                Iterator<Entry<String, CedarType>> it = fields.entrySet().iterator();
                while (fieldIndex > 0) {
                    it.next();
                    fieldIndex--;
                }
                Entry<String, CedarType> entry = it.next();

                valueExpr = new PropertyAccessExpression(valueExpr, entry.getKey(), null);
                valueType = entry.getValue();
            }
        }

        ExpressionWithType result = new ExpressionWithType();
        result.expression = valueExpr;
        result.exprType = valueType;
        return result;
    }

    private static ExpressionWithType generateValueOfType(CedarType requiredType,
            EntityPool entities, SchemaWrapper schema) {

        if (randomChance(75) || requiredType.getTypeId() == CedarType.TypeId.BOOL) {
            // Crude but, hopefully, effective: just generate expressions until we get one with the right type.
            for (int i = 0; i < 20; i++) {
                ExpressionWithType attempt = generateValueExpr(entities, schema, false);
                if (attempt.exprType.equals(requiredType)) {
                    return attempt;
                }
            }
        }

        // Generate a literal of the required type:

        if (requiredType.getTypeId() == CedarType.TypeId.ENTITY) {
            Entity entity = entities.getRandomEntityOfType((CedarEntityRef)requiredType, random);
            if (entity != null) {
                ExpressionWithType result = new ExpressionWithType();
                result.expression = new EntityExpression(entity.getEntityId(),
                        Arrays.asList(entity.getEntityType()), null);
                result.exprType = requiredType;
                return result;
            }
        }
        else if (requiredType.getTypeId() == CedarType.TypeId.LONG) {
            int value = random.nextInt(100); // number from 0-99
            ExpressionWithType result = new ExpressionWithType();
            result.expression = new LongExpression(value, null);
            result.exprType = requiredType;
            return result;
        }
        else if (requiredType.getTypeId() == CedarType.TypeId.BOOL) {
            boolean value = (random.nextInt(2) == 0);
            ExpressionWithType result = new ExpressionWithType();
            result.expression = new BooleanExpression(value, null);
            result.exprType = requiredType;
            return result;
        }
        else if (requiredType.getTypeId() == CedarType.TypeId.RECORD) {
            ExpressionWithType result = new ExpressionWithType();
            result.expression = new RecordExpression(Collections.emptyMap(), null); // TODO generate field values
            result.exprType = requiredType;
            return result;
        }
        else if (requiredType.getTypeId() == CedarType.TypeId.STRING) {
            ExpressionWithType result = new ExpressionWithType();
            String stringValue = "string" + random.nextInt(30);
            result.expression = new StringExpression(stringValue, null);
            result.exprType = requiredType;
            return result;
        }

        throw new UnsupportedOperationException("Can't handle: " + requiredType.getTypeId().toString());
    }

    private static String generateCondition(EntityPool entities, SchemaWrapper schema) {
        String result;
        if (randomChance(50)) {
            result = "unless {\n";
        } else {
            result = "when {\n";
        }

        result += "    " + generateConditionExpression(entities, schema);
        result += "\n}";

        return result;
    }

    // TODO support multiple principal/resource types; combine with type tests ("is"/"has") to avoid errors
    private static Expression generateConditionExpression(EntityPool entities, SchemaWrapper schema) {
        // x in y
        // x == y (constant or other)
        // arithmetic:  x < y, x > y

        // 'principal', 'resource', 'action' -- refer to appropriate entity/action (entity reference)
        // 'context' -- refers to request context (record)

        ExpressionWithType combineValue = null;
        ExpressionWithType value;

        boolean skipBinOp;

        while (true) {
            value = generateValueExpr(entities, schema, false);

            skipBinOp = false;
            if (value.exprType.getTypeId() == CedarType.TypeId.BOOL) {
                if (randomChance(70)) {
                    // It's a boolean value so can be used as a condition:
                    if (randomChance(50))
                        skipBinOp = true;
                    else {
                        value.expression = new UnaryExpression(UnaryExpression.UnaryOp.Not,
                                value.expression, null);
                        skipBinOp = true;
                    }
                }
            }

            if (!skipBinOp) {
                // We now need a comparison or other operator, to another value of appropriate type
                ExpressionWithType otherValue;
                do {
                    otherValue = generateValueOfType(value.exprType, entities, schema);
                } while (value.expression.toString().equals(otherValue.expression.toString()));

                // TODO set membership ("in"), type tests ("is")

                BinaryExpression.BinaryOp operation = null;

                if (value.exprType.getTypeId() == CedarType.TypeId.LONG && randomChance(50)) {
                    // For numbers we can do relational comparisons as well as equality
                    int opIndex = random.nextInt(6);
                    switch (opIndex) {
                    case 0:
                        operation = BinaryExpression.BinaryOp.LessEq; break;
                    case 1:
                        operation = BinaryExpression.BinaryOp.Less; break;
                    case 2:
                        operation = BinaryExpression.BinaryOp.Eq; break;
                    case 3:
                        operation = BinaryExpression.BinaryOp.Neq; break;
                    case 4:
                        operation = BinaryExpression.BinaryOp.Greater; break;
                    case 5:
                        operation = BinaryExpression.BinaryOp.GreaterEq; break;
                    }
                }
                else {
                    int opIndex = random.nextInt(2);
                    switch (opIndex) {
                    case 0:
                        operation = BinaryExpression.BinaryOp.Eq; break;
                    case 1:
                        operation = BinaryExpression.BinaryOp.Neq; break;
                    }
                }

                value.expression = new BinaryExpression(value.expression, operation, otherValue.expression, null);
                value.exprType = CedarPrimitive.BOOL;
            }

            if (combineValue != null) {
                BinaryExpression.BinaryOp operation = null;
                int opIndex = random.nextInt(2);
                switch (opIndex) {
                case 0:
                    operation = BinaryExpression.BinaryOp.And; break;
                case 1:
                    operation = BinaryExpression.BinaryOp.Or; break;
                }
                value.expression = new BinaryExpression(combineValue.expression, operation, value.expression, null);
            }

            if (randomChance(75)) break;

            // On the next pass combine another boolean expression with the one we have now:
            combineValue = value;
        }

        return value.expression;
    }
}
