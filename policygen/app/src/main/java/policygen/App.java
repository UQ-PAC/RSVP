/*
 * This source file was generated by the Gradle 'init' task
 */
package policygen;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Random;
import java.util.Set;

import policygen.entity.Entity;
import policygen.entity.FileResource;
import policygen.entity.Folder;
import policygen.entity.Group;
import policygen.entity.User;

public class App {

    private static Random random = new Random();

    private static ArrayList<User> userList;
    private static ArrayList<Group> groupList;
    private static ArrayList<Folder> folderList;
    private static ArrayList<FileResource> fileList;

    // Generate permit, forbid policies;
    // Some with conditions;
    // Try to ensure conditions not redundant?

    // Principals:
    //   User::"username"
    //   Group::"groupname"
    // (Users can be in a group, groups can be in a group, there should be no cycles)
    //
    // "User" attributes:
    //    accessLevel (0 - 9)
    //    age (generated as 15 - 99)
    //    (parent: group)
    //
    // "Group":
    //    (parent: group)
    //
    // Resources:
    //   File::"filename"
    //      attributes:
    //         requiredLevel (0-9)
    //         owner (->User)
    //         creator (->User)
    //   Folder::"foldername"
    //      attributes as per file
    //
    // Actions:
    //   Action::"read"
    //   Action::"update"
    //   Action::"remove"
    //
    // Requests (environment):
    // (appear in condition clauses as "context.xxx")
    //    srcSubnet (string)
    //    maintenanceMode (bool)


    public static void main(String[] args) {
        Group adminGroup = new Group("Admins", null);
        Group staffGroup = new Group("Staff", null);
        Group seniorStaffGroup = new Group("SeniorStaff", staffGroup);

        groupList = new ArrayList<>();
        groupList.add(adminGroup);
        groupList.add(staffGroup);
        groupList.add(seniorStaffGroup);

        userList = new ArrayList<>();
        userList.add(new User("Joe", 25, 5, adminGroup));
        userList.add(new User("Sally", 33, 7, staffGroup));
        userList.add(new User("Matumbah", 56, 3, seniorStaffGroup));
        userList.add(new User("Philip", 21, 3, null /* no group */));

        folderList = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            folderList.add(new Folder(null));
        }

        fileList = new ArrayList<>();
        for (int i = 0; i < 100; i++) {
            Folder parent = folderList.get(random.nextInt(folderList.size()));
            fileList.add(new FileResource(parent));
        }

        for (int i = 0; i < 100; i++) {
            generatePolicy();
        }
    }

    private static boolean randomChance(int percent) {
        return random.nextInt(100) < percent;
    }

    private static void generatePolicy() {
        // "permit" or "forbid"?
        // 60% permit
        boolean isPermit = randomChance(60);
        String policyStr = isPermit ? "permit (\n" : "forbid {\n";

        // Need principal, action, resource, conditions
        String principal = randomPrincipal();
        policyStr += "    " + principal + ",\n";

        String action = randomAction();
        policyStr += "    " + action + ",\n";

        String resource = randomResource();
        policyStr += "    " + resource + "\n";

        policyStr += ");\n";
        System.out.println(policyStr);
    }

    private static String randomPrincipal() {
        return randomMultiple("principal", userList, groupList);
    }

    private static String randomResource() {
        return randomMultiple("resource", fileList, folderList);
    }

    private static String randomMultiple(String entityType, ArrayList<? extends Entity> primaries, ArrayList<? extends Entity> group) {
        // Can be a specific principal ('principal == User::"boo_radley"'), a membership check
        // ('principal in Group::"fun_llamas"') or membership from any in a list
        // ('principal in [User::"one", User::"two", Group::"some_group"]')

        int principalForm = random.nextInt(100);
        if (principalForm == 0) {
            return entityType;
        }
        if (principalForm < 40) {
            int principalId = random.nextInt(primaries.size());
            return entityType + " == " + primaries.get(principalId).toEntityString();
        }
        else if (principalForm < 80) {
            int groupId = random.nextInt(group.size());
            return entityType + " in " + group.get(groupId).toEntityString();
        }
        else {
            // At least two entities
            // Maximum 1/4 of principal entities in each category (users, groups)
            // Maximum 10 of each

            int maxUserCount = primaries.size() / 4;
            maxUserCount = Math.max(maxUserCount, 10);
            maxUserCount = Math.min(Math.min(2, primaries.size()), maxUserCount);

            int maxGroupCount = group.size() / 4;
            maxGroupCount = Math.max(maxGroupCount, 10);
            maxGroupCount = Math.min(Math.min(2, group.size()), maxGroupCount);

            int userCount;
            int groupCount;
            do {
                userCount = random.nextInt(maxUserCount + 1);
                groupCount = random.nextInt(maxGroupCount + 1);
            }
            while (userCount + groupCount < 2);

            // Choose principals (users, groups)

            Set<Entity> chosenPrincipals = new HashSet<>();
            for (int i = 0; i < userCount; i++) {
                int principalId = random.nextInt(primaries.size());
                if (!chosenPrincipals.add(primaries.get(principalId))) {
                    // already chosen, try again
                    i--; continue;
                }
            }
            for (int i = 0; i < groupCount; i++) {
                int principalId = random.nextInt(group.size());
                if (!chosenPrincipals.add(group.get(principalId))) {
                    // already chosen, try again
                    i--; continue;
                }
            }

            // Build string

            String principalStr = entityType + " in [";
            boolean firstPrincipal = true;
            for (Entity chosen : chosenPrincipals) {
                if (!firstPrincipal) {
                    principalStr += ", ";
                }
                principalStr += chosen.toEntityString();
                firstPrincipal = false;
            }
            principalStr += "]";
            return principalStr;
        }
    }

    private static String randomAction() {
        int actionIndex = random.nextInt(4);
        switch (actionIndex) {
        case 0:
            return "action == Action::\"read\"";
        case 1:
            return "action == Action::\"update\"";
        case 2:
            return "action == Action::\"remove\"";
        default: /* 3 */
            return "action";
        }
    }
}
